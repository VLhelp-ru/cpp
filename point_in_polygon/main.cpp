/*
***** COPYRIGHT: VLhelp.ru / program@vlhelp.ru *****

Данная программа реализует метод трассирвоки лучей для определения находится заданная точка внутри многоугольника или снаружи
Алгоритм заключен в следующем:
	- из заданной точки выпускаем луч параллельно оси Ox в ее положительном направлении
	- последовательно перебираем ребра многоугольника и проверяем какие из них пересекает луч, увеличиваем счетчик пересечений
	- если счетчик пересечений четный, то точка лежит вне многоугольника, иначе - внутри

*/

// подключаем библиотеки
#include <stdio.h>
#include <stdlib.h>

// определяем константы
#define MAX_VERTEX 50 // максимальное число вершин
#define MAX_POINTS 50 // максимальное число точек
#define BIG_INT 10000 // большое число (нужно для луча из точки)

// функции нахождения минимума и максимума
#define min(a, b) (a < b ? a : b)
#define max(a, b) (a > b ? a : b)

const double EPS = 1e-9;

// определяем точку как структуру
typedef struct
{
	int x, y; // координаты
	void print() // функция вывода на экран
	{
		printf("(%d, %d)\n", x, y);
	}
} Point;

Point poly[MAX_VERTEX];
Point point[MAX_POINTS];
Point p;

int vertex_count = 0; // счетчик числа вершин, увеличивается по мере считывания из файла
int points_count = 0; // счетчик числа точек, увеличивается по мере считывания из файла

// функция выводит на экран вершины многоугольника
// параметры: P - многоугольник, n - число вершин
void print_poly(Point *P, int n)
{
	for (int i = 0; i < n; i++)
		printf("(%d, %d)\n", P[i].x, P[i].y);
}

// функция считает определитель, 1-я строка которого это a и b, вторая c и d
double det (double a, double b, double c, double d)
{
	return a * d - b * c;
}

// функция определяет пересекает ли луч ребро многоугольника
bool line_intersect(Point a, Point b, Point c, Point d)
{
	// любая прямая в 2-мерном пространстве задается уравнением Ax + By + C = 0
	// считаем коэффициенты для уравнения 1-й прямой
	int A1 = a.y - b.y;
	int B1 = b.x - a.x;
	int C1 = a.x * b.y - b.x * a.y;

	// считаем коэффициенты для уравнения 2-й прямой
	int A2 = c.y - d.y;
	int B2 = d.x - c.x;
	int C2 = c.x * d.y - d.x * c.y;

	// считаем определитель, первая строка которого содержит коэффициенты 1-го уравнения, 2-я строка - кооэффициенты 2-го уравнения
	double zn = det(A1, A2, B1, B2);
	if (abs(zn)  < EPS) // проверяем на параллельность // если определитель по модулю меньше заданного EPS, то прямые параллельны
		return false;

	// находим координаты xi и yi точки пересечения 2-х прямых
	double xi = -det(C1, B1, C2, B2) / zn;
	double yi = -det(A1, C1, A2, C2) / zn;

	// если координаты точки пересечения не попадают в диапазон, органиченный отрезками, то пересечение не засчитываем, т.к. нас интересует именно пересечение отрезков, а не бесконечных пряиых
	if (xi < min(a.x,b.x) || xi > max(a.x,b.x))	return false;
	if (xi < min(c.x,d.x) || xi > max(c.x,d.x)) return false;

	//printf("line (%d, %d) - (%d, %d) cross line (%d, %d) - (%d, %d) at point (%f, %f)\n", a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y, xi, yi); // служебный вывод

	return true;
}

// функция проверяет находится ли точка p внутри многоугольника poly с числом вершин n
bool point_in_polygon(Point p, Point* poly, int n)
{
	int count = 0; // счетчик числа пересеченных ребер
	for (int i = 0; i < n; i++) // проходим циклом по всем вершинам
	{
		// чтобы определить ребро (отрезок) многоугольника, нужны вершины a и b
		Point a = poly[i]; // вершина a
		Point b = (i == n-1 ? poly[0] : poly[i+1]); // вершина b. если текущая i-ая вершина последняя в списке, то следующая будет первая вершина многоугольника, т.к. многоугольник - замкнутая фигура

		// создаем новую точку отдаленную от исходной на большое расстояние по оси Ox
		Point p1; // точка
		p1.x = BIG_INT; // по оси X точка находится на очень большом расстоянии
		p1.y = p.y; // по оси Y координата не изменяется
		if (line_intersect(p, p1, a, b)) // если есть пересечение
			count++; // увеличиваем счетчик числа пересечений
	}
	return (count % 2 == 0 ? false : true); // если число пересечений четно, то точка снаружи, иначе - внутри
}

// функция считывает многоугольник с файла
// формат файла: 1-я строка содержит число вершин, следующие строки содержат координаты x и y вершины, разделенные пробелом
void read_polygon(const char* file)
{
	FILE *f = NULL; // создаем указатель на файловую переменную
	f = fopen(file, "r"); // открываем файл в режиме чтения
	if (!f) // если файл не удалось открыть
	{
		printf("Cannot open file \'%s\'\n", file); // оповещаем пользователя
		return; // дальнейшее чтение файл не производим, выходим из фунцкии
	}
	int n = 0; // число считанных данных
	n = fscanf(f, "%d", &vertex_count); // считываем число вершин, находящееся в первой строке файла в переменную vertex_count
	if (n != 1) // если число вершин не считано
	{
		fclose(f); // закрываем файл
		printf("File \'%s\' damaged\n", file); // предупреждаем пользователя о том, что файл поврежден
		return; // дальнейшее чтение не производим, выходим из функции
	}
	int v = 0; // переменная для числа фактически считанных вершин
	while (!feof(f)) // пока не достигнут конец файла
	{
		if (v > MAX_VERTEX) // если считано максимально допустимое число вершин, то прекращаем чтение (выходим из цикла)
			break;
		n = fscanf(f, "%d%d", &poly[v].x, &poly[v].y); // считываем координаты x и y из текущей строки файла
		v++; // увеличиваем счетчик фактически считанных вершин
	}
	vertex_count = v; // устанавливаем количество вершин для алгоритма равное фактическому
	fclose(f); // закрываем файл
}

// функция считывает точки, работает аналогично read_polygon
void read_points(const char* file)
{
	FILE *f = NULL;
	f = fopen(file, "r");
	if (!f)
	{
		printf("Cannot open file \'%s\'\n", file);
		return;
	}
	int n = 0;
	n = fscanf(f, "%d", &points_count);
	if (n != 1)
	{
		fclose(f);
		printf("File \'%s\' damaged\n", file);
		return;
	}
	int p = 0;
	while (!feof(f))
	{
		if (p > MAX_POINTS)
			break;
		n = fscanf(f, "%d%d", &point[p].x, &point[p].y);
		p++;
	}
	points_count = p;
	fclose(f);
}

int main()
{
	read_polygon("polygon.txt"); // считываем многоугольник
	read_points("points.txt"); // считываем точки
	const char* output = "output.txt"; // выходной файл

	FILE *f = NULL;
	f = fopen(output, "w");
	if (!f)
	{
		printf("Cannot create file \'%s\'\n", output);
		return 0;
	}
	for (int i = 0; i < points_count; i++)
	{
		if (point_in_polygon(point[i], poly, vertex_count))
			fprintf(f, "Point (%d, %d) is INSIDE of polygon.\n", point[i].x, point[i].y);
		else
			fprintf(f, "Point (%d, %d) is OUTSIDE of polygon.\n", point[i].x, point[i].y);
	}
	fclose(f);
    return 0;
}
